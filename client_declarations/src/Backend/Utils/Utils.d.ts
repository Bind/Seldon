import { BigInteger } from 'big-integer';
import { StatIdx } from '../../_types/global/GlobalTypes';
import { Planet, EthAddress, Upgrade, UpgradeBranchName } from '@darkforest_eth/types';
export declare const ONE_DAY: number;
declare type NestedBigIntArray = (BigInteger | string | NestedBigIntArray)[];
declare type NestedStringArray = (string | NestedStringArray)[];
export declare const hexifyBigIntNestedArray: (arr: NestedBigIntArray) => NestedStringArray;
export declare const getUpgradeStat: (upgrade: Upgrade, stat: StatIdx) => number;
export declare const hslStr: (h: number, s: number, l: number) => string;
export declare const getPlayerColor: (player: EthAddress) => string;
export declare const getOwnerColor: (planet: Planet) => string;
export declare const formatNumber: (num: number) => string;
export declare const getRandomActionId: () => string;
export declare const getFormatProp: (planet: Planet | undefined, prop: string) => string;
export declare const getPlanetRank: (planet: Planet | undefined) => number;
export declare const getPlanetShortHash: (planet: Planet | undefined) => string;
export declare const getPlayerShortHash: (address: EthAddress) => string;
export declare const isFullRank: (planet: Planet | undefined) => boolean;
export declare const upgradeName: (branchName: UpgradeBranchName) => string;
export declare const getPlanetMaxRank: (planet: Planet | undefined) => number;
export declare const titleCase: (title: string) => string;
export declare const hasOwner: (planet: Planet) => boolean;
export declare function sleep<T>(timeout: number, returns?: T): Promise<T>;
export declare function rejectAfter<T>(ms: number, msg: string): Promise<T>;
export declare function neverResolves(): Promise<void>;
export declare const aggregateBulkGetter: <T>(logTag: string, total: number, querySize: number, getterFn: (startIdx: number, endIdx: number) => Promise<T[]>, onProgress?: ((fractionCompleted: number) => void) | undefined) => Promise<T[]>;
export declare type RetryErrorHandler = (i: number, e: Error) => void;
export declare const callWithRetry: <T>(fn: (...args: unknown[]) => Promise<T>, args?: unknown[], onError?: RetryErrorHandler | undefined, maxRetries?: number, retryInterval?: number) => Promise<T>;
export declare const timeoutAfter: <T>(promise: Promise<T>, ms: number, timeoutMsg: string) => Promise<T>;
export declare function deferred<T>(): [(t: T) => void, (t: Error) => void, Promise<T>];
export {};
